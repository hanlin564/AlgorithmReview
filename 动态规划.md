# 动态规划

### [1. 剑指offer 10-I.斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

```java
class Solution {
    public int fib(int n) {
        int sum = 0, pre1 = 1, pre2 = 0;
        for(int i = 0; i < n; i++){
            sum = (pre1 + pre2) % 1000000007;
            pre2 = pre1;
            pre1 = sum;            
        }
        //为何返回pre2而不是result？
        //pre2的初始值是0，经过1次迭代后pre2=f(1)=1
        //n次迭代后pre2=f(n)，故返回pre2
        return pre2;
    }
}
```



### [2. 剑指offer 10-II.青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

```java
class Solution {
    public int numWays(int n) {
      //这个题和上一题基本一样，区别是pre2的初始值为1了
      //pre1:跳到当前台阶的前一个台阶的总跳法数
      //pre2:跳到当前台阶的前两个台阶的总跳法数
      //sum:跳到当前台阶的总跳法数
      //为什么要初始化两个pre值为1：可以想象成青蛙是从第0级台阶向上跳的，直接跳到第一级和第二级的方式皆为1种
        int pre1 = 1, pre2 = 1, sum;
        for (int i = 0; i < n; i++) {
            sum = (pre1 + pre2) % 1000000007;
            pre2 = pre1;
            pre1 = sum;
        }
        return pre2;
    }
}
```



### [3. 剑指offer 42.连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        //dp[i](res)代表以nums[i]结尾的连续子数组的最大和
        //dp[i]只与dp[i-1]和nums[i]有关系。为了节省空间，就不用dp数组了，直接在原数组上做修改得了
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            //当nums[i-1]<=0时，把nums[i-1]添加进连续子数组中是对“使dp[i]最大”有副作用的，还不如不加入
            //此时dp[i]=nums[i]
            //如果nums[i-1]>0，那么加入nums[i]是对dp[i]有增加效果的，此时dp[i]=dp[i-1]+nums[i]
            nums[i] += Math.max(nums[i - 1], 0);
            //选择最大的dp[i]
            res = Math.max(res, nums[i]);
        }
        return res;
    }
}
```



### [4. 剑指offer 47.礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

```java
class Solution {
    public int maxValue(int[][] grid) {
        int m = grid.length, n = grid[0].length;
      /*
      对于最左侧一列和最上面一行的单元格，它们只能由上面单元格或左边单元格的价值转移而来
      所以要在代码中判断当前是否为最左侧一列或最上面一行的单元格
      当矩阵很大时，我们可以先用循环初始化这两个边界的值，以减少冗余的判断次数
      */
        for (int i = 1; i < m; i++) {
            grid[i][0] += grid[i - 1][0];
        }
        for (int j = 1; j < n; j++) {
            grid[0][j] += grid[0][j - 1];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                grid[i][j] += Math.max(grid[i - 1][j], grid[i][j - 1]);
            }
        }
        return grid[m - 1][n - 1];
    }
}
```



### [5. 剑指offer 48.最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        //map用于存储每个字符最后在s中出现的下标
        Map<Character, Integer> lastIndexForChar = new HashMap<>();
        //maxSubLen用于存储最长不重复子串长度，会随着遍历而改变
        //tmp用于临时存储当前不重复子串的长度
        int maxSubLen = 0, tmp = 0;
        for (int j = 0; j < s.length(); j++){
            //从map中取得当前字符上一次出现的下标，记为i；若这个字符是第一次出现，则记i=-1
            int i = lastIndexForChar.getOrDefault(s.charAt(j), -1);
            //更新map中当前字符最后出现的下标位置，置为当前位置
            lastIndexForChar.put(s.charAt(j), j);
            //当前不重复子串的长度可能从两种状态转移而来：
            //1.当前字符最后出现位置到当前位置的距离>不重复子串的长度，这说明子串并没有包含之前出现的那个重复字符，
            //也即是长度为tmp的子串没有s.charAt(i)。这情况可以把s.charAt(j)加入到子串中，长度+1（tmp+1）
            //2.当前字符最后出现位置到当前位置的距离<=不重复子串的长度，这说明子串包含了s.charAt(i)，不能加入s.charAt(j)了
            //此时当前子串已经到了最长长度了，记为j-i；需要从下一个字符从0重新计算子串长度
            tmp = tmp < j - i ? tmp + 1 : j - i;
            maxSubLen = Math.max(maxSubLen, tmp);
        }
        return maxSubLen;
    }
}
```



### [6. 剑指offer 49.丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

```java
class Solution {
    public int nthUglyNumber(int n) {
        //一个丑数可以分解为2^x * 3^y * 5^z的形式，其中xyz为任意非负整数
        //从而可以推断出，一个较大的丑数可以由一个较小的整数乘2或3或5得到
      //p2,p3,p5是指向dp数组中已经求出的丑数的指针，因为要使dp[i]尽可能的小，所以每次得出来新的丑数之后都使指针往后走一位
        int p2 = 0, p3 = 0, p5 = 0;
        //dp为从小到大排序生成的丑数列表
        int[] dp = new int[n];
        dp[0] = 1;//已知1是丑数
        for (int i = 1; i < n; i++) {
            //如何求下一个丑数？由此前已求出的某个丑数乘2或3或5，取其中最小的那个为下一个丑数
            int n2 = dp[p2] * 2, n3 = dp[p3] * 3, n5 = dp[p5] * 5;
            dp[i] = Math.min(Math.min(n2, n3), n5);
            // 第p2个数已经通过乘2得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(p2+1)个数
            if (dp[i] == n2) p2++;
            // 第p3个数已经通过乘3得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(p3+1)个数
            if (dp[i] == n3) p3++;
            // 第p5个数已经通过乘5得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(p5+1)个数
            if (dp[i] == n5) p5++;
        }
        return dp[n - 1];
    }
}
```



### [7. 剑指offer 60.n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

```java
class Solution {
    public double[] dicesProbability(int n) {
        //dp数组和tmp数组：dp表示骰子数为n-1时，各点数和的概率；tmp表示骰子数为n时，各点数和的概率
        //求tmp要用到dp，所以不能直接在dp上做修改（会影响计算结果）
        double[] dp = new double[6];
        //当骰子数为1时，点数之和可能取1到6的整数，可能性都是1/6，故用1.0/6.0填充dp作为初始化
        Arrays.fill(dp, 1.0 / 6.0);
        for (int i = 2; i <= n; i++) {
            //每次增加一个骰子，点数之和的范围会发生变化，不仅往大的值取得更多，有一些比较小的值也取不到了
            //比方说，n=3（三个骰子）时，点数之和是不可能取到1或2的。因此要考虑到之前能取到，增加了一个骰子就取不到的值
            //观察后发现骰子数i和点数之和的种类数的关系是：点数之和的可能情况数=5 * i + 1
            //6*i-(i-1)化简得到5*i+1
            double[] tmp = new double[5 * i + 1];
            //从骰子数为i-1的各点数和中取一个，与骰子数为i新加入的骰子中的某个点数相加
            //骰子数为i-1的点数和有dp.length种可能
            //骰子数为i新加入的骰子的可能取值有6种，每种取到的可能性为1.0/6.0
          	//这里除6.0难以理解，背住就好
            for (int j = 0; j < dp.length; j++) {
                for (int k = 0; k < 6; k++) {
                    tmp[j + k] += dp[j] / 6.0;
                }
            }
            //当骰子数为n时，各点数和的概率计算完毕，需要让dp指向tmp，更新n-1为此前的n
            dp = tmp;
        }
        return dp;
    }
}
```



### [8. 剑指offer 66.构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

<img src="http://pic.hanlin564.xyz/6056c7a5009cb7a4674aab28505e598c502a7f7c60c45b9f19a8a64f31304745-Picture1.png" alt="Picture1.png" style="zoom:50%;" />

```java
class Solution {
  //B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]
  //思路：先计算A[i]左边的数的乘积，再计算右边的数的乘积，最终把这两个结果相乘（动态规划）
    public int[] constructArr(int[] a) {
        if (a.length == 0)   return new int[0];
      //b数组用于保存最终答案，其中b[i]表示除了下标i以外的元素的积
        int[] b = new int[a.length];
      //第一和倒数第一的元素都初始化为1
        b[0] = 1;
        int tmp = 1;
      //在第一次循环中，b[i]表示下标i左侧的数的乘积，即为A[0]×A[1]×…×A[i-1]
      //循环从第二个元素开始
        for (int i = 1; i < a.length; i++) {
          //b[i - 1]等同于A[0]×A[1]×…×A[i-2]
          //b[i]=(A[0]×A[1]×…×A[i-2])*A[i - 1]
            b[i] = b[i - 1] * a[i - 1];
        }
      //在第二次循环中，用tmp来存储下标i右侧的数的乘积，即为A[i+1]×…×A[n-1]
      //循环从倒数第二个元素开始
        for (int i = a.length - 2; i >= 0; i--) {
            tmp *= a[i + 1];
          //b[i]此前已经保存了i左侧元素的乘积，它只需与右侧元素的乘积相乘即为最终答案
            b[i] *= tmp;
        }
        return b;
    }
}
```

