# 栈、队列、堆

### [1. 剑指offer 09.用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```java
class CQueue {
    private Stack<Integer> in = new Stack<>();
    private Stack<Integer> out = new Stack<>();

    public CQueue() {
        
    }
    
    public void appendTail(int value) {
        in.push(value);
    }
    
    public int deleteHead() {
        //注意：先队两个栈都为空的情况进行判断，可以节约时间
        if (out.isEmpty() && in.isEmpty()) {
            return -1;
        }
        if (out.isEmpty()) {
            inToOut();
        }
        return out.pop();
    }

    private void inToOut(){
        if(out.isEmpty()){
            while (!in.isEmpty()) {
                out.push(in.pop());
            }
        }        
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```



### [2. 剑指offer 30.包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

```java
class MinStack {
    //data存储所有的元素
    private Stack<Integer> data;
    //min栈从栈底到栈顶是降序的
    //存储当前data栈元素对应的最小值
    private Stack<Integer> min;

    /** initialize your data structure here. */
    public MinStack() {
        data=new Stack<>();
        min=new Stack<>();
    }
    
    public void push(int x) {
        data.push(x);
        //如果min栈为空或x比min栈顶的元素还小(x为最小值)
        if (min.isEmpty() || x<=min.peek()) {
            //把x压入min栈
            min.push(x);
        }
    }
    
    public void pop() {
        //若data栈中栈顶的元素等于当前最小值
        if (data.pop().equals(min.peek())) {
            //min栈顶元素出栈
            min.pop();
        }
    }
    
    public int top() {
        return data.peek();
    }
    
    public int getMin() {
        return min.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```



### [3. 剑指offer 31.栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        //用stack来模拟push/pop操作的顺序
        Stack<Integer> stack = new Stack<>();
        int index = 0;//index用于访问popped数组中的元素
        for (int num : pushed) {
            //遍历pushed数组并按顺序把num压入栈中
            stack.push(num);
            //当栈顶元素等于popped数组中index指向的元素时，通过while循环把符合弹出序列的栈顶元素全部弹出
            while (!stack.isEmpty() && stack.peek() == popped[index]){
                stack.pop();
                index++;//注意栈顶弹出后要让index++
            }
        }
        //若栈为空，则弹出序列合法
        return stack.isEmpty();
    }
}
```



### [4. 剑指offer 40.最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

```java
class Solution {
    public int[] getLeastNumbers(int[] arr, int k) {
        //如果k大于数组长度，就直接把整个数组返回
        if (k >= arr.length)    return arr;
        return quickSort(arr, k, 0, arr.length - 1);
    }

    private void swap(int[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    private int[] quickSort(int[] arr, int k, int left, int right){
        int i = left, j = right;
        //找基准数（排序区间的第一个数arr[left]）的在排序数组中的位置
        //外层的while循环结束时i==j，这就是基准数的位置
        while (i < j){
            while (i < j && arr[j] >= arr[left])    j--;
            while (i < j && arr[i] <= arr[left])    i++;
            //比基准数小的放在左侧，大的放在右侧
            swap(arr, i, j);
        }
        //把基准数放在排序后的位置
        swap(arr, i, left);
        //如果基准数下标大于k，说明k在基准数的左侧，递归排序左侧
        if (i > k)
            return quickSort(arr, k, left, i - 1);
        //否则k在基准数的右侧，只需递归排序右侧
        if (i < k)
            return quickSort(arr, k, i + 1, right);
        //返回排序数组中的前k个数
        return Arrays.copyOf(arr, k);
    }
}
```



### [5. 剑指offer 59-I.滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 0 || k == 0) return new int[0];
        //用双端队列来存储滑动窗口中的部分元素，这些元素从队首到队尾不严格降序，队首为极大值
        Deque<Integer> deque = new LinkedList<>();
        //滑动窗口共有nums.length - k + 1个
        int[] res = new int[nums.length - k + 1];
        //第一次循环，对应还没有形成滑动窗口的情况
        for (int i = 0; i < k; i++) {
            //此时不需要考虑队首元素的出队问题，只需要更新队尾就行了
            //这个while循环的作用是把比nums[i]小的元素全部从队尾出队，循环结束后把nums[i]加入队列
            //就是确保没有大于nums[i]的元素后再让它入队
            while (!deque.isEmpty() && deque.peekLast() < nums[i]){
                deque.removeLast();
            }
            deque.addLast(nums[i]);
        }
        //第一个滑动窗口的最大值就是第一次循环结束后的队首元素的值
        res[0] = deque.peekFirst();
        //第二次循环，对应形成了滑动窗口的情况
        for (int i = k; i < nums.length; i++) {
            //如果队首元素就是当前滑动窗口最左侧的元素，需要使其出队
            //因为下一个滑动窗口中必然已经没有当前滑动窗口最左侧的元素了，要排除它以免影响判断
            if (deque.peekFirst() == nums[i - k]){
                deque.removeFirst();
            }
            //这里和第一次循环是一样的
            while (!deque.isEmpty() && deque.peekLast() < nums[i]){
                deque.removeLast();
            }
            deque.addLast(nums[i]);
            //把滑动窗口的值按顺序加入到res中
            res[i - k + 1] = deque.peekFirst();
        }
        return res;
    }
}
```



### [6. 剑指offer 59-II.队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

```java
class MaxQueue {
    //queue为队列，deque为双端队列（头尾皆可执行出队操作）
    //queue中存放队列中的所有数据
    Queue<Integer> queue;
    //deque按单调不增的顺序从头到尾存储部分数据，队头为当前队列中的最大值
    Deque<Integer> deque;

    public MaxQueue() {
        queue = new LinkedList<>();
        deque = new LinkedList<>();
    }
    
    public int max_value() {
        //若deque为空就返回-1，否则返回deque的队头
        return deque.isEmpty() ? -1 : deque.peekFirst();
    }
    
    public void push_back(int value) {
        //把新入队元素放入queue中
        queue.offer(value);
        //把deque中比新元素小的整数都从队尾出队，然后把新元素放在deque中相应的单调不增的位置
        while (!deque.isEmpty() && deque.peekLast() < value){
            deque.pollLast();
        }
        deque.offerLast(value);
    }
    
    public int pop_front() {
        if(queue.isEmpty()) return -1;
        //若出队元素和最大值相等，则deque队首也要出队
        if (queue.peek().equals(deque.peekFirst()))
            deque.pollFirst();
        //queue队首出队
        return queue.poll();
    }
}

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue obj = new MaxQueue();
 * int param_1 = obj.max_value();
 * obj.push_back(value);
 * int param_3 = obj.pop_front();
 */
```

