# 字符串

### [1. 回文子串（647）](https://leetcode-cn.com/problems/palindromic-substrings/)

中心扩展法：

```java
class Solution {
    int ans=0;

    public int countSubstrings(String s) {
        for (int i = 0; i < s.length(); i++) {
            //回文子串长度为奇数(以一个字符为中心)
            extendSubstrings(s, i, i);
            //回文子串长度为偶数(以两个字符为中心)
            extendSubstrings(s, i, i+1);
        }
        return ans;
    }

    //中心扩展
    public void extendSubstrings(String s,int start,int end){
        //使ans++,且使回文子串前后都增加一个字符的条件:
        //1.回文子串的开始和结束位置在s字符串内
        //2.前后的字符是相同的
        while (start>=0 && end<s.length() && s.charAt(start)==s.charAt(end)) {
            start--;
            end++;
            ans++;
        }
    }
}
```



### [2. 最长回文子串（5）](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```java
class Solution {
    public String longestPalindrome(String s) {
        int start = 0, end = 0;

        for (int i = 0; i < s.length(); i++) {
            int oddLen = extendSubstrings(s, i, i);
            int evenLen = extendSubstrings(s, i, i + 1);
            int maxLen = Math.max(oddLen, evenLen);
            if (maxLen > end - start) {
                start = i - (maxLen - 1) / 2;
                end = i + maxLen / 2;
            }
        }

        return s.substring(start, end + 1);
    }

    private int extendSubstrings(String s, int start, int end) {
        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
            start--;
            end++;
        }
        return end - start - 1;
    }
}
```



### [3. 最长有效括号（32）](https://leetcode-cn.com/problems/longest-valid-parentheses/)

```java
class Solution {
    public int longestValidParentheses(String s) {
        //left和right分别记录左右括号的数量，maxLength记录当前最长有效括号的长度
        int left = 0, right = 0, maxLength = 0;
        //从左向右遍历
        for (int i = 0; i < s.length(); i++) {
            //统计左右括号的数量
            if (s.charAt(i) == '('){
                left++;
            }else {
                right++;
            }
            //当左括号等于右括号时，说明可以构成有效括号，尝试更新maxLength
            if (left == right){
                maxLength = Math.max(maxLength, 2 * left);
            }else if (right > left){
                //当右括号大于左括号，说明不可能构成有效括号，把左右括号的数量置为0
                left = right = 0;
            }
            //但是这样会漏掉左括号大于右括号的情况，比方说"(()"就统计不了了，所以要从右往左遍历一次
        }
        //重置左右括号的数量，从右往左遍历一次
        left = right = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == '('){
                left++;
            }else {
                right++;
            }
            if (left == right){
                maxLength = Math.max(maxLength, 2 * left);
            }else if (left > right){
                left = right = 0;
            }
        }
        return maxLength;
    }
}
```



### [4. 字符串解码（394）](https://leetcode-cn.com/problems/decode-string/)

```java
class Solution {
    public String decodeString(String s) {
        return dfs(s, 0)[0];
    }

    //首先解释下String[]是什么
    //当String[]的长度为2时，第二个元素为解码出的子字符串，第一个元素为解码出的子字符串的最后字符']'在s中的下标
    //当String[]的长度为1时，数组中只存储了解码出的字符串
    //dfs函数的意思：对字符串s从i往后的子串进行解码，并存在数组里；必要的时候还会在数组里存子串最后那个']'的下标
    private String[] dfs(String s, int i){
        StringBuilder res = new StringBuilder();
        //multi为k[encoded_string]的k，是一个正整数
        int multi = 0;
        while (i < s.length()){
            //当前字符为数字，需要更新multi的值
            //为啥要乘10？因为是从左往右扫描的，如果k不是个位数而是n位整数的话就要通过不停的乘10来更新值
            if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
                multi = 10 * multi + Integer.parseInt(String.valueOf(s.charAt(i)));
            //当前字符为'['，此时需要递归地去解码'['后面的子串
            else if (s.charAt(i) == '['){
                //子串从'['的下一位开始，用tmp保存解码的结果和子串最后的']'在s中的下标
                String[] tmp = dfs(s, i + 1);
                //更新i的值，由于在上一行的递归中子串以及子串内部的子串都被求出来了，所以在外层就不用管它们了，直接把i跳到tmp[0]表示的位置
              	//这里我们可以清楚地知道在递归函数的结果中保存子串的最后的']'下标的意义了
              	//因为可以直接在外层的递归中跳过已经在内层的递归中处理的字符串部分
                i = Integer.parseInt(tmp[0]);
                //这个while循环达到了把k[encoded_string]内的encoded_string在res后拼接k次的效果（这里的encoded_string就是tmp[1]）
                while (multi > 0){
                    res.append(tmp[1]);
                    multi--;
                }
            }
            //当前字符为']'，返回这个子串结尾处的下标和其解码结果
            else if (s.charAt(i) == ']'){
                return new String[] {String.valueOf(i), res.toString()};
            }
            //当前字符为非数字、非'['']'，则把它拼接到res后
            else {
                res.append(String.valueOf(s.charAt(i)));
            }
            //i后移
            i++;
        }
        return new String[] {res.toString()};
    }
}
```



### [5. 最小覆盖子串（76）](https://leetcode-cn.com/problems/minimum-window-substring/)

```java
class Solution {
    public String minWindow(String s, String t) {
        //排除一些非法情况
        if (s == null || s.length() == 0 || t == null || t.length() == 0) {
            return "";
        }
        //need数组用于表示每个字符的需要个数
      	//ASCII码一共有128个
        int[] need = new int[128];
        //先遍历t，记录下需要的字符个数
        for (int i = 0; i < t.length(); i++) {
            need[t.charAt(i)]++;
        }
        //left和right分别是当前滑动窗口的左右边界，size是当前滑动窗口的大小
        //count是当前需求的字符个数
        //start是最小覆盖串开始处的下标
        int left = 0, right = 0, size = Integer.MAX_VALUE, count = t.length(), start = 0;
        //遍历s字符串
        while (right < s.length()) {
            //取出当前右边界的字符
            char c = s.charAt(right);
            //need[c]大于0，说明这个字符c在t里面出现了need[c]次
            //need[c]小于等于0，说明这个字符c在t里面没有出现
            //当c在t中出现了，说明c可以放入滑动窗口内，并为"凑成覆盖字串"的目标做贡献，我们把count--以表示需要凑的字符数量减1
            if (need[c] > 0) {
                count--;
            }
            //无论c是否能为最小覆盖字串做贡献，都要对其进行need[c]--操作
            need[c]--;
            //当count为0时，说明这个滑动窗口内已经包含了全部t中的字符
            //这时就要试图把left右移来得到最小的滑动窗口
            if (count == 0) {
                //当need[s.charAt(left)] < 0时，说明左边界处的字符没对最小覆盖字串没贡献，也即是说，我们不需要s.charAt(left)
                //忽略掉这样不需要的字符以得到更小的窗口（即把左边界右移，同时更新need数组）
                while (left < right && need[s.charAt(left)] < 0) {
                    need[s.charAt(left)]++;
                    left++;
                }
                //若当前滑动窗口大小小于此前的最小滑动窗口大小，则更新size和start
                if (right - left + 1 < size) {
                    size = right - left + 1;
                    start = left;
                }
                //这里讨论下为啥要对need[s.charAt(left)]++和left++
                //上面的need[c]--操作，这导致了s中所有字符的需要次数都比实际的少1
                //那么这时的最小滑动窗口的左边界的need值是0，这是因为前面while循环的退出条件是need[s.charAt(left)] < 0
                //可是左边界的字符的需要次数为1，不然它不可能算在滑动窗口内，所以要对其进行++操作
                need[s.charAt(left)]++;
                //左边界右移，这样滑动窗口内肯定不包含t中的所有字符了，一切都要重新计算了
                left++;
                //由于左边界只右移了一位，说明只有一个字符不被包含
                //count++，表示要重新开始凑的字符由0变为1
                count++;
            }
            //右边界右移
            right++;
        }
        //在s中截取start到start+size的字串作为结果返回
        return size == Integer.MAX_VALUE ? "" : s.substring(start, start + size);
    }
}
```



### [6. 字母异位词分组（49）](https://leetcode-cn.com/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        //map的key是属于同一种字母异位词的出现的字母及其出现次数
        //value是存放同一种字母异位词的链表
        Map<String, List<String>> map = new HashMap<String, List<String>>();
        for (String str : strs) {
            //用int数组保存str中每个小写字母出现的次数
            int[] count = new int[26];
            int length = str.length();
            for (int i = 0; i < length; i++) {
                count[str.charAt(i) - 'a']++;
            }
            //sb最终要转为string，作为map的键值
            //sb存放的是字符串中出现的字母及其出现次数
            //比方说当sb为"a2b3"，说明该字符串有2个a，3个b
            //由于生成sb的顺序是固定的，所以字母异位词生成的sb都是一样的
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 26; i++) {
                if (count[i] != 0) {
                    sb.append((char) ('a' + i));
                    sb.append(count[i]);
                }
            }
            String key = sb.toString();
            //从map中取得存放相应的链表并插入到最后
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(str);
            //覆盖map对应value
            map.put(key, list);
        }
        //把map中所有的链表转换成list形式返回
        return new ArrayList<List<String>>(map.values());
    }
}
```

