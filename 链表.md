# 链表

### [1. 剑指offer 06.从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {
        int lenOfList = 0;
        ListNode current = head;//用current代指head，避免直接使用head导致丢失了头节点
        //先取得链表长度，并创建相应长度的数组
        while (current != null) {
            lenOfList++;
            current = current.next;
        }
        int[] ans = new int[lenOfList];
        current = head;
        //把链表从尾到头放进ans数组中
        while (current != null) {
            ans[lenOfList - 1] = current.val;
            lenOfList--;
            current = current.next;
        }
        return ans;
    }
}
```



### [2. 剑指offer 18.删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if (head == null) {
            return null;
        }
        if (head.val == val) {
            return head.next;
        }
        ListNode cur = head;
        while (cur.next != null && cur.next.val != val) {
            cur = cur.next;
        }
        if (cur.next != null) {
            cur.next = cur.next.next;
        }
        return head;
    }
}
```



### [3. 剑指offer 22.链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode fast = head, slow = head;
        for (int i = 0; i < k; i++) {
            fast = fast.next;
        }
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }
        return slow;
    }
}
```



### [4. 剑指offer 24.反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

迭代法：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode res = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode nextTemp = cur.next;
            cur.next = res;
            res = cur;
            cur = nextTemp;
        }
        return res;
    }
}
```



递归法：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null || head.next==null)
            return head;
        ListNode result = reverseList(head.next);
        head.next.next=head;
        head.next=null;
        return result;
    }
}
```



### [5. 剑指offer 25.合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        }
        if (l2 == null) {
            return l1;
        }
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l2.next, l1);
            return l2;
        }
    }
}
```



### [6. 剑指offer 35.复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null)   return null;

        //遍历原链表，把每一个节点都复制一次，并把复制后的节点加在原节点后头
        //node1->newnode1->node2->newnode2....
        Node cur = head;
        while (cur != null){
            Node tmp = new Node(cur.val);
            tmp.next = cur.next;
            cur.next = tmp;
            cur = tmp.next;
        }

        //遍历复制后的链表
        //看似遍历了链表中所有节点，其实不然
        //只是把复制后的节点的random指针指向其它复制的节点罢了，老节点的指针状况是不改变的
        cur = head;
        while (cur != null){
            if (cur.random != null)
                cur.next.random = cur.random.next;
            cur = cur.next.next;//由于只更改新复制出来的节点，所以一次往后移动两个位置
        }

        //把链表中的新旧节点分为两个链表，返回新链表的头节点作为答案
        cur = head.next;
        Node pre = head, res = head.next;
        while (cur.next != null){
            pre.next = pre.next.next;
            cur.next = cur.next.next;
            pre = pre.next;
            cur = cur.next;
        }
        pre.next = null;
        return res;
    }
}
```



### [7. 剑指offer 52.两个链表的第一个节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;
        while (a != b) {
            a = (a == null ? headB : a.next);
            b = (b == null ? headA : b.next);
        }
        return a;
    }
}
```



### [8. 删除链表的倒数第N个节点（19）](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head, slow = head;
        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        while (fast != null && fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        //对要删除头节点的情况做特殊处理
        if (fast == null) {
            return head.next;
        } else {
            slow.next = slow.next.next;
            return head;
        }
    }
}
```



### [9. 回文链表（234）](https://leetcode-cn.com/problems/palindrome-linked-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }
        ListNode slow = head, fast = head.next;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        if (fast != null) {
            slow = slow.next;
        }
        cut(head, slow);
        return isEqual(head, reverse(slow));
    }

    private ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode res = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return res;
    }

    private boolean isEqual(ListNode headA, ListNode headB) {
        while (headA != null && headB != null) {
            if (headA.val != headB.val) {
                return false;
            }
            headA = headA.next;
            headB = headB.next;
        }
        return true;
    }

    private void cut(ListNode head, ListNode cutNode) {
        while (head.next != cutNode) {
            head = head.next;
        }
        head.next = null;
    }
}
```



### [10. 合并k个升序链表（23）](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;

        //用优先队列来存放还没有被合并的链表的头节点，升序排列
        //优先队列会动态维护顺序，无论如何队首元素都是最小的
        PriorityQueue<ListNode> queue = new PriorityQueue<ListNode>(lists.length, new Comparator<ListNode>() {
            @Override
            public int compare(ListNode o1, ListNode o2) {
                if (o1.val < o2.val)    return -1;
                else if (o1.val == o2.val)   return 0;
                else    return 1;
            }
        });

        //创建一个head节点，作为最终答案的链表的头节点，head本身无意义只是方便操作
        ListNode head = new ListNode(0);
        //tail指针一开始指向链表头
        ListNode tail = head;
        //遍历lists中的所有链表头节点，把它们都加入到优先队列中
        for (ListNode node : lists) {
            if (node != null)   queue.add(node);
        }
        while (!queue.isEmpty()){
            //把优先队列的队首节点出队加入到答案链表的最后
            tail.next = queue.poll();
            tail = tail.next;
            //注意：虽然队首节点加入到了答案链表最后，但是这个队首节点与它原来的链表还是通过指针连在一起的
            //如果原链表还有元素，那这个元素就成了原链表新的头节点，也要加入优先队列
            if (tail.next != null) queue.add(tail.next);
        }
        return head.next;
    }
}
```



### [11. 排序链表（148）](https://leetcode-cn.com/problems/sort-list/)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null) {
            return head;
        }

        //取得了链表的长度
        int length = 0;
        ListNode node = head;
        while (node != null) {
            length++;
            node = node.next;
        }
        //新建一个dummyHead方便操作
        ListNode dummyHead = new ListNode(0, head);
        //subLength为这一轮要归并的子链表长度，每归并一次变大一倍(subLength <<= 1)
        //每次归并从左向右进行，两两归并
        for (int subLength = 1; subLength < length; subLength <<= 1) {
            //pre指向已完成这一轮归并的部分链表的最后一个节点，cur指向还没完成这一轮归并的部分链表的第一个节点
            ListNode pre = dummyHead, cur = dummyHead.next;
            while (cur != null) {
                ListNode head1 = cur;
                //这个循环是为了找到cur节点后隔了subLength长度的位置，即另一个子链表的头节点
                //为啥是subLength次循环？因为head1的子链表的长度就是subLength啊
                for (int i = 1; i < subLength && cur.next != null; i++) {
                    cur = cur.next;
                }
                ListNode head2 = cur.next;
                //断开两个子链表的连接
                cur.next = null;
                //这个循环使cur指向了head2+subLength的位置
                cur = head2;
                for (int i = 1; i < subLength && cur != null && cur.next != null; i++) {
                    cur = cur.next;
                }
                //先判断下cur是不是null，如果是null，说明整个链表都被归并了一次
                //注意并不是说归并排序结束了，而是说这一轮的归并结束了
                //若这一轮还没结束，就断开还未归并的部分和head2链表尾部的连接，用next临时保存下还未归并部分的头节点
                ListNode next = null;
                if (cur != null) {
                    next = cur.next;
                    cur.next = null;
                }
                //对head1和head2进行有序链表的合并，保存在merged里
                //head1和head2有序的原因：归并是从每个子链表只有1个数开始进行的，所以肯定有序
                //理解成递归直接从最内层开始就行了
                ListNode merged = merge(head1, head2);
                //把新归并出来的部分接在已归并部分的最后
                pre.next = merged;
                //更新pre的位置，重新使其指向已完成归并部分的尾部
                while (pre.next != null) {
                    pre = pre.next;
                }
                //cur指向未完成此轮归并部分的头节点
                cur = next;
            }
        }
        //返回完成归并的链表
        return dummyHead.next;
    }

    private ListNode merge(ListNode head1, ListNode head2) {
        if (head1 == null) {
            return head2;
        }
        if (head2 == null) {
            return head1;
        }
        if (head1.val < head2.val) {
            head1.next = merge(head1.next, head2);
            return head1;
        }else {
            head2.next = merge(head2.next, head1);
            return head2;
        }
    }
}
```

