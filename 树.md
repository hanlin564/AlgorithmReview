# 树

### [1. 剑指offer 07.重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    Map<Integer, Integer> indexForTreeNode;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int m = preorder.length;
        //把中序遍历的节点与索引用hashmap保存起来
        indexForTreeNode = new HashMap<>();
        for(int i = 0; i < m; i++){
            indexForTreeNode.put(inorder[i], i);
        }
        //返回构造二叉树的根节点
        return build(preorder, inorder, 0, m - 1, 0, m - 1);
    }

    //preorder_left：前序遍历中左子树第一个节点的位置
    //preorder_right：前序遍历中右子树最后一个节点的位置
    //inorder_left：中序遍历中左子树第一个节点的位置
    //inorder_right：中序遍历中右子树最后一个节点的位置
    private TreeNode build(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right){
        //递归终止条件
        if(preorder_left > preorder_right){
            return null;
        }
        //前序遍历的根节点就是第一个节点（preorder[0]）
        int preorder_root = preorder_left;
        //通过根节点值从map中获取根节点在inorder中的下标
        int inorder_root = indexForTreeNode.get(preorder[preorder_root]);
        //通过节点值构造根节点
        TreeNode root = new TreeNode(preorder[preorder_root]);
        //左子树的元素个数
        int sizeOfLeftSub = inorder_root - inorder_left;
        //对左右子树进行递归操作
        root.left = build(preorder, inorder, preorder_left + 1, preorder_left + sizeOfLeftSub, inorder_left, inorder_root - 1);
        root.right = build(preorder, inorder, preorder_left + sizeOfLeftSub + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }
}
```



### [2. 剑指offer 26.树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        //1.首先两个树不为null
        //2.两种情况：第一种是B可以直接从A的根节点开始，匹配出相应的子结构；第二种是B要在A的左子树或右子树中才能找到相应的子结构
        return (A != null && B != null) && (matching(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    }

    //把树B与树A中的某个节点开始进行匹配(B是根节点，A不是根节点)
    private boolean matching(TreeNode A, TreeNode B){
        //当B为null，说明从B的根节点开始到某个叶子节点这条路径都成功匹配了A中的一部分，返回true
        if (B == null)  return true;
        //1.当A为null，说明此时B中的这条路径还没到叶子节点，但是A已经没有可以进行匹配的节点了，返回false
        //2.两个节点值不等，返回false
        if (A == null || A.val != B.val)    return false;
        //递归：在A中试图匹配B的左子树和B的右子树
        return matching(A.left, B.left) && matching(A.right, B.right);
    }
}
```



### [3. 剑指offer 27.二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        swap(root);
        mirrorTree(root.left);
        mirrorTree(root.right);
        return root;
    }

    private void swap(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
}
```



### [4. 剑指offer 28.对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isSymmetrical(root.left, root.right);
    }

    private boolean isSymmetrical(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) {
            return true;
        }
        if (t1 == null || t2 == null) {
            return false;
        }
        if (t1.val != t2.val) {
            return false;
        }
        return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
    }
}
```



### [5. 剑指offer 32-I.从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] levelOrder(TreeNode root) {
        if (root == null)   return new int[0];//开辟一个没有长度的数组
        Queue<TreeNode> queue = new LinkedList<>();
        List<Integer> ans = new ArrayList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            TreeNode node = queue.poll();
            ans.add(node.val);
            if (node.left != null)  queue.add(node.left);
            if (node.right != null)  queue.add(node.right);
        }
        int[] res = new int[ans.size()];
        for (int i = 0; i < ans.size(); i++) {
            res[i] = ans.get(i);
        }
        return res;
    }
}
```



### [6. 剑指offer 32-II.从上到下打印二叉树II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        if (root != null)   queue.add(root);
        while (!queue.isEmpty()){
            //tmp中按顺序存储了这一层的所有节点值，遍历完该层后tmp加入res中表示一层
            List<Integer> tmp = new ArrayList<>();
            //把当前层的节点出队，并把下一层的节点从左到右放入队列中
            //在该循环开始时，queue中只存储了下一层的节点，queue.size()就是下一层的节点总数
            for (int i = queue.size(); i > 0; i--) {
                TreeNode node = queue.poll();
                tmp.add(node.val);//把这一层的节点值加入tmp中
                if (node.left != null)  queue.add(node.left);
                if (node.right != null) queue.add(node.right);
            }
            res.add(tmp);
        }
        return res;
    }
}
```



### [7. 剑指offer 32-III.从上到下打印二叉树III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        //队列
        Queue<TreeNode> queue = new LinkedList<>();
        //保存最终答案的链表
        List<List<Integer>> res = new ArrayList<>();
        //把根节点加入队列
        if(root != null)
            queue.add(root);
        while (!queue.isEmpty()) {
            //双向链表，注意不能用List接口初始化而要用LinkedList，
            //因为只有LinkedList才有addLast和addFirst方法
            LinkedList<Integer> tmp = new LinkedList<>();
            //i初始化为queue.size()，因为queue的大小是变化的，要一开始确定遍历的次数
            for(int i = queue.size(); i > 0; i--){
                TreeNode node = queue.poll();
                //当res的层数为偶数时，说明当前遍历的这一层是奇数层，正序遍历
                if(res.size() % 2 == 0)
                    tmp.addLast(node.val);
                else
                    //当res的层数为奇数时，说明当前遍历的这一层是偶数层，倒序遍历
                    tmp.addFirst(node.val);
                //把下一层的节点从左到右按顺序加入队列中
                if(node.left != null)   queue.add(node.left);
                if(node.right != null)  queue.add(node.right);
            }
            res.add(tmp);
        }
        return res;
    }
}
```

