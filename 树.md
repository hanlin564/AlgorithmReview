# 树

### [1. 剑指offer 07.重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    Map<Integer, Integer> indexForTreeNode;

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int m = preorder.length;
        //把中序遍历的节点与索引用hashmap保存起来
        indexForTreeNode = new HashMap<>();
        for(int i = 0; i < m; i++){
            indexForTreeNode.put(inorder[i], i);
        }
        //返回构造二叉树的根节点
        return build(preorder, inorder, 0, m - 1, 0, m - 1);
    }

    //preorder_left：前序遍历中左子树第一个节点的位置
    //preorder_right：前序遍历中右子树最后一个节点的位置
    //inorder_left：中序遍历中左子树第一个节点的位置
    //inorder_right：中序遍历中右子树最后一个节点的位置
    private TreeNode build(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right){
        //递归终止条件
        if(preorder_left > preorder_right){
            return null;
        }
        //前序遍历的根节点就是第一个节点（preorder[0]）
        int preorder_root = preorder_left;
        //通过根节点值从map中获取根节点在inorder中的下标
        int inorder_root = indexForTreeNode.get(preorder[preorder_root]);
        //通过节点值构造根节点
        TreeNode root = new TreeNode(preorder[preorder_root]);
        //左子树的元素个数
        int sizeOfLeftSub = inorder_root - inorder_left;
        //对左右子树进行递归操作
        root.left = build(preorder, inorder, preorder_left + 1, preorder_left + sizeOfLeftSub, inorder_left, inorder_root - 1);
        root.right = build(preorder, inorder, preorder_left + sizeOfLeftSub + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }
}
```



### [2. 剑指offer 26.树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        //1.首先两个树不为null
        //2.两种情况：第一种是B可以直接从A的根节点开始，匹配出相应的子结构；第二种是B要在A的左子树或右子树中才能找到相应的子结构
        return (A != null && B != null) && (matching(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));
    }

    //把树B与树A中的某个节点开始进行匹配(B是根节点，A不是根节点)
    private boolean matching(TreeNode A, TreeNode B){
        //当B为null，说明从B的根节点开始到某个叶子节点这条路径都成功匹配了A中的一部分，返回true
        if (B == null)  return true;
        //1.当A为null，说明此时B中的这条路径还没到叶子节点，但是A已经没有可以进行匹配的节点了，返回false
        //2.两个节点值不等，返回false
        if (A == null || A.val != B.val)    return false;
        //递归：在A中试图匹配B的左子树和B的右子树
        return matching(A.left, B.left) && matching(A.right, B.right);
    }
}
```



### [3. 剑指offer 27.二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        swap(root);
        mirrorTree(root.left);
        mirrorTree(root.right);
        return root;
    }

    private void swap(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
}
```



### [4. 剑指offer 28.对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isSymmetrical(root.left, root.right);
    }

    private boolean isSymmetrical(TreeNode t1, TreeNode t2) {
        if (t1 == null && t2 == null) {
            return true;
        }
        if (t1 == null || t2 == null) {
            return false;
        }
        if (t1.val != t2.val) {
            return false;
        }
        return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
    }
}
```

