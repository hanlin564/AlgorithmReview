# 搜索

## BFS

### [1. 完全平方数（279）](https://leetcode-cn.com/problems/perfect-squares/)

```java
class Solution {
    // 可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，
    // 那么这两个整数所在的节点就有一条边。
    // 要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。
    public int numSquares(int n) {
        //构成n的完全平方数的大小肯定在1~n之间，所以要生成一个包含了1~n所有的完全平方数的序列备用
        List<Integer> squares = generateSquares(n);
        Queue<Integer> queue = new LinkedList<>();
        //用于标记一个在1到n之间的数是否被访问过
      	//我们试图从n减去一个完全平方数，再把这个运算的结果减去一个完全平方数...直到为0
      	//这样就说明n是某些完全平方数的和
      	//显然n减去一个小于n的正数位于1～n之间，故我们的数组长度为n+1
      	//marked标记的是cur-square的运算结果，这样就不必对可能出现的相同运算结果做重复处理了，保证队列里是不同的元素，节约空间和时间
        boolean[] marked = new boolean[n + 1];
        queue.add(n);
        marked[n] = true;
        int count = 0;//用于记录路径长度
        while (!queue.isEmpty()) {
            int size = queue.size();
          	//这一层的可能的next距离n是减去相同次数的完全平方数的
            count++;
            while (size-- > 0) {
                int cur = queue.poll();
                for (int square : squares) {
                    int next = cur - square;//next为当前数减去一个完全平方数
                    //若next小于0，退出循环
                  	//因为squares中的数是从小到大排序的
                  	//当前next小于0说明继续循环没意义了
                  	//因为继续循环后面的next都是小于0的
                    if (next < 0) {
                        break;
                    }
                    //若next等于0，返回count作为结果
                  	//若到最外层循环正常退出时，都没有凑出next==0的情况，没有返回count
                  	//那说明n这个数不可能由除了1之外的完全平方数凑成
                    if (next == 0) {
                        return count;
                    }
                    //若next已被访问过，则跳过当前循环
                    if (marked[next]) {
                        continue;
                    }
                  	//正常情况下应该来到这里：标记next访问过并使其入队
                    marked[next] = true;
                    queue.add(next);
                }
            }
        }
      
      	//最坏情况：n由n个1组成（1是完全平方数）
        return n;
    }

    //生成1,4,9,...,n的完全平方数序列
    private List<Integer> generateSquares(int n){
        List<Integer> squares = new ArrayList<>();
        int square = 1, diff = 3;
        while (square <= n) {
            squares.add(square);
            square += diff;
            diff += 2;
        }
        return squares;
    }
}
```

![IMG_2035](http://pic.hanlin564.xyz/IMG_2035.jpg)

## DFS

### [1. 剑指offer 13.机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

```java
class Solution {
    int m, n, k;
    boolean[][] visited;//用于标记每个单元格的访问情况，true表示访问过

    public int movingCount(int m, int n, int k) {
        this.m = m; this.n = n; this.k = k;
        this.visited = new boolean[m][n];
        //从矩阵左上角开始dfs
        return dfs(0, 0, 0, 0);
    }

    //递归计算从某个单元格开始机器人可达的格子数量
    //i,j为单元格的纵横坐标；si,sj为单元格纵横坐标的数位和
    private int dfs(int i, int j, int si, int sj){
        //下标越界 || 坐标数位和大于k || 当前单元格已被访问过
        //返回0
        if (i >= m || j >= n || k < si + sj || visited[i][j]){
            return 0;
        }
        //标记这个格子已经被访问过了（不用回溯！）
        visited[i][j] = true;
        //递归计算从某个单元格开始机器人可达的格子数量：这个单元格本身算一个可达的格子（1）+向下移动的可达格子数量+向右移动的格子数量
        //(i + 1) % 10 != 0 ? si + 1 : si - 8的意思（j+1同理）：
        //如果i+1发生了进位（比如从9到10，从19到20，从199到200...），可观察发现，i+1的数位和相比于i减少了8
        //如果i+1每发生进位（从1到2，从15到16，从151到152...），可观察发现，i+1的数位和相比于i增加了1
        return 1 + dfs(i + 1, j, (i + 1) % 10 != 0 ? si + 1 : si - 8, sj) + dfs(i, j + 1, si, (j + 1) % 10 != 0 ? sj + 1 : sj - 8);
    }
}
```



## 回溯

### [1. 剑指offer 12.矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++){
            for(int j = 0; j < board[0].length; j++){
                //从0开始
                if(dfs(board, words, i, j, 0)){
                    return true;
                }
            }
        }
        return false;
    }

    //k表示words数组中0~k下标的字母都在矩阵中找到了路径
    private boolean dfs(final char[][] board, final char[] words, int row, int col, int k){
        //排除下标越界以及无法找到相等字母的情况
        if(row >= board.length || row < 0 || col >= board[0].length || col < 0 ||
           board[row][col] != words[k]){
            return false;
        }
        //此时已经找到了word在矩阵中的路径，返回true
        if(k == words.length - 1){
            return true;
        }
        //使用Java中的空字符'\0'来标记当前格子已被访问过，节约了visited数组的空间
        board[row][col] = '\0';
        //对四个方向进行dfs，有一个为true就返回
        boolean res = dfs(board, words, row + 1, col, k + 1) || 
            		 dfs(board, words, row - 1, col, k + 1) ||
                      dfs(board, words, row, col + 1, k + 1) || 
            		 dfs(board, words, row, col - 1, k + 1);
        //回溯
        board[row][col] = words[k];
        return res;
    }
}
```



### [2. 剑指offer 38.字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

```java
class Solution {
    List<String> res = new LinkedList<>();
    char[] c;

    public String[] permutation(String s) {
        //需要注意：c是"abc"三个字符构成的char数组，排列顺序可能不同，但是不会重复也不会出现其它字符，长度也不会变化，一直都为3
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    }

    //从第x位开始dfs（x从0开始，到2结束）
    private void dfs(int x){
        //若x等于2，说明dfs到底了，把当前char数组c转换为string并加入res中就行了
        if (x == c.length - 1){
            res.add(String.valueOf(c));
            return;
        }

        //set用于防止一个排列中出现多次出现同一个字符
        HashSet<Character> set = new HashSet<>();
        //这里是在讨论第x位出现字符的各种可能性
        for (int i = x; i < c.length; i++) {
            //当字符出现重复就略过这个字符
            if (set.contains(c[i])) continue;
            //把c[i]加入set中以标记访问过
            set.add(c[i]);
            //把第i位与第x位做交换，表示现在第x位的字符固定为c[i]了
            swap(i, x);
            //固定了第x位的字符，开始对x+1位进行dfs
            dfs(x + 1);
            //回溯
            swap(i, x);
          	//为什么回溯的时候不把c[i]从set中移除啊？
          	//题目并没说给的字符串s中的每个字符都是唯一的，也就是说可能出现重复
          	//那么在探讨c[i]处可以有多少种字母摆放方式时，遇到相同的字符就直接忽略，提升效率
          	//因为c[i]和c[x]相同时，交换它们两个字符是毫无意义的
          	//再来看这个set，它是在dfs的方法内部定义的
          	//这说明每个dfs方法内部，都会new一个set出来
          	//倘若在循环的前期就已经把字符"a"固定于x位置并以其为前提进行排列种类的讨论
          	//若循环的后期再次遇到"a"(与上面的a是两个相同但处于字符串不同位置的字符)
          	//便无需把后面的a与前面的a进行交换，因为固定a的讨论已经做过一遍了，不用重复了
        }
    }

    //交换char数组中下标a和b的字符
    private void swap(int a, int b){
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    }
}
```



